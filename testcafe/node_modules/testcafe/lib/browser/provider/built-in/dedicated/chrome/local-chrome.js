"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stop = exports.startOnDocker = exports.start = void 0;
const testcafe_browser_tools_1 = __importDefault(require("testcafe-browser-tools"));
const process_1 = require("../../../../../utils/process");
const browser_starter_1 = __importDefault(require("../../../utils/browser-starter"));
const build_chrome_args_1 = require("./build-chrome-args");
const chrome_remote_interface_1 = __importDefault(require("chrome-remote-interface"));
const timer_1 = __importDefault(require("../../../../../utils/timer"));
const delay_1 = __importDefault(require("../../../../../utils/delay"));
const browserStarter = new browser_starter_1.default();
const LIST_TABS_TIMEOUT = 10000;
const LIST_TABS_DELAY = 500;
async function start(pageUrl, { browserName, config, cdpPort, tempProfileDir, isContainerized, isNativeAutomation }) {
    const chromeInfo = await testcafe_browser_tools_1.default.getBrowserInfo(config.path || browserName);
    const chromeOpenParameters = Object.assign({}, chromeInfo);
    chromeOpenParameters.cmd = (0, build_chrome_args_1.buildChromeArgs)({ config, cdpPort, platformArgs: chromeOpenParameters.cmd, tempProfileDir, isContainerized, isNativeAutomation });
    await browserStarter.startBrowser(chromeOpenParameters, pageUrl);
}
exports.start = start;
async function tryListTabs(cdpPort) {
    try {
        return { tabs: await chrome_remote_interface_1.default.List({ port: cdpPort }) };
    }
    catch (error) {
        return { error };
    }
}
async function startOnDocker(pageUrl, { browserName, config, cdpPort, tempProfileDir, isContainerized }) {
    await start('', { browserName, config, cdpPort, tempProfileDir, isContainerized });
    let { tabs, error } = await tryListTabs(cdpPort);
    const timer = new timer_1.default(LIST_TABS_TIMEOUT);
    //NOTE: We should repeat getting 'List' after a while because we can get an error if the browser isn't ready.
    while ((error || !tabs.length) && !timer.expired) {
        await (0, delay_1.default)(LIST_TABS_DELAY);
        ({ tabs, error } = await tryListTabs(cdpPort));
    }
    if (error)
        throw error;
    const target = tabs.filter(t => t.type === 'page')[0];
    const { Target } = await (0, chrome_remote_interface_1.default)({ target, port: cdpPort });
    await Target.createTarget({ url: pageUrl });
    await chrome_remote_interface_1.default.Close({ id: target.id, port: cdpPort });
}
exports.startOnDocker = startOnDocker;
async function stop({ browserId }) {
    // NOTE: Chrome on Linux closes only after the second SIGTERM signall
    if (!await (0, process_1.killBrowserProcess)(browserId))
        await (0, process_1.killBrowserProcess)(browserId);
}
exports.stop = stop;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWwtY2hyb21lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2Jyb3dzZXIvcHJvdmlkZXIvYnVpbHQtaW4vZGVkaWNhdGVkL2Nocm9tZS9sb2NhbC1jaHJvbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0ZBQWtEO0FBQ2xELDBEQUFrRTtBQUNsRSxxRkFBNEQ7QUFDNUQsMkRBQXNEO0FBQ3RELHNGQUFtRDtBQUNuRCx1RUFBK0M7QUFDL0MsdUVBQStDO0FBRS9DLE1BQU0sY0FBYyxHQUFHLElBQUkseUJBQWMsRUFBRSxDQUFDO0FBRTVDLE1BQU0saUJBQWlCLEdBQUcsS0FBSyxDQUFDO0FBQ2hDLE1BQU0sZUFBZSxHQUFLLEdBQUcsQ0FBQztBQUV2QixLQUFLLFVBQVUsS0FBSyxDQUFFLE9BQU8sRUFBRSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsa0JBQWtCLEVBQUU7SUFDdkgsTUFBTSxVQUFVLEdBQWEsTUFBTSxnQ0FBWSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLFdBQVcsQ0FBQyxDQUFDO0lBQzNGLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFM0Qsb0JBQW9CLENBQUMsR0FBRyxHQUFHLElBQUEsbUNBQWUsRUFBQyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLG9CQUFvQixDQUFDLEdBQUcsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGtCQUFrQixFQUFFLENBQUMsQ0FBQztJQUU3SixNQUFNLGNBQWMsQ0FBQyxZQUFZLENBQUMsb0JBQW9CLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDckUsQ0FBQztBQVBELHNCQU9DO0FBRUQsS0FBSyxVQUFVLFdBQVcsQ0FBRSxPQUFPO0lBQy9CLElBQUk7UUFDQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUNBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDO0tBQy9EO0lBQ0QsT0FBTyxLQUFLLEVBQUU7UUFDVixPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7S0FDcEI7QUFDTCxDQUFDO0FBRU0sS0FBSyxVQUFVLGFBQWEsQ0FBRSxPQUFPLEVBQUUsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFO0lBQzNHLE1BQU0sS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO0lBRW5GLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakQsTUFBTSxLQUFLLEdBQVcsSUFBSSxlQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUVuRCw2R0FBNkc7SUFDN0csT0FBTyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7UUFDOUMsTUFBTSxJQUFBLGVBQUssRUFBQyxlQUFlLENBQUMsQ0FBQztRQUU3QixDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7S0FDbEQ7SUFFRCxJQUFJLEtBQUs7UUFDTCxNQUFNLEtBQUssQ0FBQztJQUVoQixNQUFNLE1BQU0sR0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxRCxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFBLGlDQUFZLEVBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFFakUsTUFBTSxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDNUMsTUFBTSxpQ0FBWSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFyQkQsc0NBcUJDO0FBRU0sS0FBSyxVQUFVLElBQUksQ0FBRSxFQUFFLFNBQVMsRUFBRTtJQUNyQyxxRUFBcUU7SUFDckUsSUFBSSxDQUFDLE1BQU0sSUFBQSw0QkFBa0IsRUFBQyxTQUFTLENBQUM7UUFDcEMsTUFBTSxJQUFBLDRCQUFrQixFQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzVDLENBQUM7QUFKRCxvQkFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBicm93c2VyVG9vbHMgZnJvbSAndGVzdGNhZmUtYnJvd3Nlci10b29scyc7XG5pbXBvcnQgeyBraWxsQnJvd3NlclByb2Nlc3MgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy9wcm9jZXNzJztcbmltcG9ydCBCcm93c2VyU3RhcnRlciBmcm9tICcuLi8uLi8uLi91dGlscy9icm93c2VyLXN0YXJ0ZXInO1xuaW1wb3J0IHsgYnVpbGRDaHJvbWVBcmdzIH0gZnJvbSAnLi9idWlsZC1jaHJvbWUtYXJncyc7XG5pbXBvcnQgcmVtb3RlQ2hyb21lIGZyb20gJ2Nocm9tZS1yZW1vdGUtaW50ZXJmYWNlJztcbmltcG9ydCBUaW1lciBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy90aW1lcic7XG5pbXBvcnQgZGVsYXkgZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvZGVsYXknO1xuXG5jb25zdCBicm93c2VyU3RhcnRlciA9IG5ldyBCcm93c2VyU3RhcnRlcigpO1xuXG5jb25zdCBMSVNUX1RBQlNfVElNRU9VVCA9IDEwMDAwO1xuY29uc3QgTElTVF9UQUJTX0RFTEFZICAgPSA1MDA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydCAocGFnZVVybCwgeyBicm93c2VyTmFtZSwgY29uZmlnLCBjZHBQb3J0LCB0ZW1wUHJvZmlsZURpciwgaXNDb250YWluZXJpemVkLCBpc05hdGl2ZUF1dG9tYXRpb24gfSkge1xuICAgIGNvbnN0IGNocm9tZUluZm8gICAgICAgICAgID0gYXdhaXQgYnJvd3NlclRvb2xzLmdldEJyb3dzZXJJbmZvKGNvbmZpZy5wYXRoIHx8IGJyb3dzZXJOYW1lKTtcbiAgICBjb25zdCBjaHJvbWVPcGVuUGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGNocm9tZUluZm8pO1xuXG4gICAgY2hyb21lT3BlblBhcmFtZXRlcnMuY21kID0gYnVpbGRDaHJvbWVBcmdzKHsgY29uZmlnLCBjZHBQb3J0LCBwbGF0Zm9ybUFyZ3M6IGNocm9tZU9wZW5QYXJhbWV0ZXJzLmNtZCwgdGVtcFByb2ZpbGVEaXIsIGlzQ29udGFpbmVyaXplZCwgaXNOYXRpdmVBdXRvbWF0aW9uIH0pO1xuXG4gICAgYXdhaXQgYnJvd3NlclN0YXJ0ZXIuc3RhcnRCcm93c2VyKGNocm9tZU9wZW5QYXJhbWV0ZXJzLCBwYWdlVXJsKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdHJ5TGlzdFRhYnMgKGNkcFBvcnQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB0YWJzOiBhd2FpdCByZW1vdGVDaHJvbWUuTGlzdCh7IHBvcnQ6IGNkcFBvcnQgfSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRPbkRvY2tlciAocGFnZVVybCwgeyBicm93c2VyTmFtZSwgY29uZmlnLCBjZHBQb3J0LCB0ZW1wUHJvZmlsZURpciwgaXNDb250YWluZXJpemVkIH0pIHtcbiAgICBhd2FpdCBzdGFydCgnJywgeyBicm93c2VyTmFtZSwgY29uZmlnLCBjZHBQb3J0LCB0ZW1wUHJvZmlsZURpciwgaXNDb250YWluZXJpemVkIH0pO1xuXG4gICAgbGV0IHsgdGFicywgZXJyb3IgfSA9IGF3YWl0IHRyeUxpc3RUYWJzKGNkcFBvcnQpO1xuICAgIGNvbnN0IHRpbWVyICAgICAgICAgPSBuZXcgVGltZXIoTElTVF9UQUJTX1RJTUVPVVQpO1xuXG4gICAgLy9OT1RFOiBXZSBzaG91bGQgcmVwZWF0IGdldHRpbmcgJ0xpc3QnIGFmdGVyIGEgd2hpbGUgYmVjYXVzZSB3ZSBjYW4gZ2V0IGFuIGVycm9yIGlmIHRoZSBicm93c2VyIGlzbid0IHJlYWR5LlxuICAgIHdoaWxlICgoZXJyb3IgfHwgIXRhYnMubGVuZ3RoKSAmJiAhdGltZXIuZXhwaXJlZCkge1xuICAgICAgICBhd2FpdCBkZWxheShMSVNUX1RBQlNfREVMQVkpO1xuXG4gICAgICAgICh7IHRhYnMsIGVycm9yIH0gPSBhd2FpdCB0cnlMaXN0VGFicyhjZHBQb3J0KSk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvcjtcblxuICAgIGNvbnN0IHRhcmdldCAgICAgPSB0YWJzLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ3BhZ2UnKVswXTtcbiAgICBjb25zdCB7IFRhcmdldCB9ID0gYXdhaXQgcmVtb3RlQ2hyb21lKHsgdGFyZ2V0LCBwb3J0OiBjZHBQb3J0IH0pO1xuXG4gICAgYXdhaXQgVGFyZ2V0LmNyZWF0ZVRhcmdldCh7IHVybDogcGFnZVVybCB9KTtcbiAgICBhd2FpdCByZW1vdGVDaHJvbWUuQ2xvc2UoeyBpZDogdGFyZ2V0LmlkLCBwb3J0OiBjZHBQb3J0IH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RvcCAoeyBicm93c2VySWQgfSkge1xuICAgIC8vIE5PVEU6IENocm9tZSBvbiBMaW51eCBjbG9zZXMgb25seSBhZnRlciB0aGUgc2Vjb25kIFNJR1RFUk0gc2lnbmFsbFxuICAgIGlmICghYXdhaXQga2lsbEJyb3dzZXJQcm9jZXNzKGJyb3dzZXJJZCkpXG4gICAgICAgIGF3YWl0IGtpbGxCcm93c2VyUHJvY2Vzcyhicm93c2VySWQpO1xufVxuIl19